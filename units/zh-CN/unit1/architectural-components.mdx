# MCP的架构组件

在上一节中，我们讨论了MCP的关键概念和术语。现在，让我们深入了解组成MCP生态系统的架构组件。

## 宿主、客户端和服务器

模型上下文协议(MCP)建立在客户端-服务器架构上，实现了AI模型与外部系统之间的结构化通信。

![MCP架构](https://huggingface.co/datasets/mcp-course/images/resolve/main/unit1/4.png)

MCP架构由三个主要组件组成，每个组件都有明确定义的角色和职责：宿主、客户端和服务器。我们在上一节中简要提到了这些，但现在让我们深入了解每个组件及其职责。

### 宿主

**宿主**是面向用户的AI应用程序，终端用户直接与其交互。

例子包括：
- AI聊天应用，如OpenAI ChatGPT或Anthropic的Claude Desktop
- AI增强的IDE，如Cursor，或像Continue.dev这样的工具集成
- 在LangChain或smolagents等库中构建的自定义AI代理和应用

宿主的职责包括：
- 管理用户交互和权限
- 通过MCP客户端发起与MCP服务器的连接
- 协调用户请求、LLM处理和外部工具之间的整体流程
- 以连贯的格式向用户呈现结果

在大多数情况下，用户将根据自己的需求和偏好选择宿主应用。例如，开发人员可能会选择Cursor来利用其强大的代码编辑功能，而领域专家可能会使用在smolagents中构建的自定义应用。

### 客户端

**客户端**是宿主应用程序内部的一个组件，负责管理与特定MCP服务器的通信。其主要特点包括：

- 每个客户端与单个服务器保持1:1连接
- 处理MCP通信的协议级细节
- 充当宿主逻辑和外部服务器之间的中介

### 服务器

**服务器**是通过MCP协议向AI模型公开功能的外部程序或服务。服务器：

- 提供对特定外部工具、数据源或服务的访问
- 作为现有功能的轻量级包装器
- 可以在本地（与宿主在同一台机器上）或远程（通过网络）运行
- 以客户端可以发现和使用的标准化格式公开其功能

## 通信流程

让我们来研究一下在典型的MCP工作流程中这些组件是如何交互的：

<Tip>

在下一节中，我们将通过实际示例深入了解实现这些组件的通信协议。

</Tip>

1. **用户交互**：用户与**宿主**应用程序交互，表达意图或查询。

2. **宿主处理**：**宿主**处理用户的输入，可能使用LLM来理解请求并确定可能需要哪些外部功能。

3. **客户端连接**：**宿主**指示其**客户端**组件连接到适当的服务器。

4. **功能发现**：**客户端**查询**服务器**以发现它提供的功能（工具、资源、提示）。

5. **功能调用**：根据用户需求或LLM的判断，宿主指示**客户端**调用**服务器**的特定功能。

6. **服务器执行**：**服务器**执行请求的功能并将结果返回给**客户端**。

7. **结果整合**：**客户端**将这些结果返回给**宿主**，后者将它们整合到LLM的上下文中或直接呈现给用户。

此架构的一个关键优势是其模块化。单个**宿主**可以通过不同的**客户端**同时连接到多个**服务器**。新的**服务器**可以添加到生态系统中，而不需要对现有**宿主**进行更改。不同**服务器**的功能可以轻松组合。

<Tip>

正如我们在上一节中讨论的，这种模块化将传统的M×N集成问题（M个AI应用程序连接到N个工具/服务）转变为更易管理的M+N问题，其中每个宿主和服务器只需实现MCP标准一次。

</Tip>

这种架构看起来可能很简单，但其力量在于通信协议的标准化和组件之间责任的明确分离。这种设计允许形成一个凝聚力强的生态系统，AI模型可以与不断增长的外部工具和数据源无缝连接。

## 结论

这些交互模式受到几个关键原则的指导，这些原则塑造了MCP的设计和演进。协议强调**标准化**，提供AI连接的通用协议，同时保持**简洁性**，保持核心协议简单但启用高级功能。优先考虑**安全性**，要求用户明确批准敏感操作，并使功能可发现。协议设计具有**可扩展性**，通过版本控制和功能协商支持演进，并确保跨不同实现和环境的**互操作性**。

在下一节中，我们将探讨使这些组件能够有效协同工作的通信协议。