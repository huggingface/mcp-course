# クイズ1：MCPサーバー実装

プルリクエストエージェントのMCPサーバーの概念と実装について知識をテストしてください。

### Q1: プルリクエストエージェントのアーキテクチャにおけるMCPサーバーの主な役割は何ですか？

<Question
  choices={[
    {
      text: "アプリケーションのユーザーインターフェースをホストする",
      explain: "MCPサーバーはバックエンド機能を提供し、ユーザーインターフェースは提供しません。"
    },
    {
      text: "AIエージェントがGitHubと相互作用するために使用できるツールとリソースを公開する",
      explain: "近いですが、このプロジェクトはGitHubではなく、Hugging Face Hubに焦点を当てています。"
    },
    {
      text: "Hugging Face Hubでモデルリポジトリのタグを読み取り、更新するためのツールを公開する",
      explain: "正解です！MCPサーバーはHubとの相互作用のためにget_current_tagsとadd_new_tagツールを提供します。",
      correct: true
    },
    {
      text: "プルリクエストデータでAIモデルを訓練する",
      explain: "MCPサーバーはランタイム機能を提供し、モデル訓練機能は提供しません。"
    }
  ]}
/>

### Q2: FastMCP実装では、なぜすべてのMCPツール関数がPythonオブジェクトではなく文字列を返す必要があるのですか？

<Question
  choices={[
    {
      text: "メモリ使用量を削減してパフォーマンスを向上させるため",
      explain: "文字列の方がメモリ効率が良い可能性がありますが、これが主な理由ではありません。"
    },
    {
      text: "MCPサーバーとクライアント間の信頼性のあるデータ交換を確保するため",
      explain: "正解です！MCPプロトコルは文字列レスポンスを要求するため、json.dumps()を使用してデータをシリアル化します。",
      correct: true
    },
    {
      text: "コードのデバッグを簡単にするため",
      explain: "JSON文字列は読みやすいですが、これは主要な技術的要件ではありません。"
    },
    {
      text: "Hugging Face Hub API要件に準拠するため",
      explain: "これはHub APIに特有ではなく、MCPプロトコルの要件です。"
    }
  ]}
/>

### Q3: `add_new_tag`ツールを実装する際、プルリクエストを作成する前にタグが既に存在するかを確認する目的は何ですか？

<Question
  choices={[
    {
      text: "API呼び出しを削減してパフォーマンスを向上させるため",
      explain: "これはパフォーマンスに役立ちますが、チェックの主な理由ではありません。"
    },
    {
      text: "重複したプルリクエストの作成を防ぎ、より良いユーザーフィードバックを提供するため",
      explain: "正解です！この検証は不要なPRを防ぎ、意味のあるステータスメッセージを返します。",
      correct: true
    },
    {
      text: "Hugging Face Hubのレート制限に準拠するため",
      explain: "不要な呼び出しを避けることはレート制限に役立ちますが、これが主な目的ではありません。"
    },
    {
      text: "タグ形式が有効であることを確認するため",
      explain: "タグの検証は、それが既に存在するかを確認することとは別です。"
    }
  ]}
/>

### Q4: MCPサーバー実装において、モデルリポジトリに既存のREADME.mdファイルがない場合、何が起こりますか？

<Question
  choices={[
    {
      text: "add_new_tagツールはエラーで失敗する",
      explain: "実装はこのケースを適切に処理します。"
    },
    {
      text: "ツールはModelCardDataで新しいModelCardを作成し、タグ追加を続行する",
      explain: "正解です！コードはHfHubHTTPErrorを処理し、存在しない場合に新しいモデルカードを作成します。",
      correct: true
    },
    {
      text: "ツールはタグの追加をスキップし、警告を返す",
      explain: "ツールは操作をスキップしません - 必要なものを作成します。"
    },
    {
      text: "ツールはプレースホルダーコンテンツでデフォルトのREADMEを自動的に作成する",
      explain: "プレースホルダーコンテンツではなく、最小限のモデルカード構造を作成します。"
    }
  ]}
/>

### Q5: `hf_api.create_commit()`関数呼び出しで`create_pr=True`を使用することの意義は何ですか？

<Question
  choices={[
    {
      text: "メインブランチに直接コミットする",
      explain: "create_pr=Trueを設定すると、メインへの直接コミットではなく、プルリクエストが作成されます。"
    },
    {
      text: "メインブランチに直接コミットする代わりに、自動的にプルリクエストを作成する",
      explain: "正解です！これによりレビューワークフローが有効になり、リポジトリガバナンスの実践に従います。",
      correct: true
    },
    {
      text: "リポジトリオーナーのみが見ることができるプライベートブランチを作成する",
      explain: "プルリクエストはリポジトリの協力者に表示され、公開される可能性があります。"
    },
    {
      text: "作成前にコミットを検証する",
      explain: "検証はcreate_prパラメータに関係なく行われます。"
    }
  ]}
/>

### Q6: MCPサーバー実装では、コード全体で絵文字を使った広範囲なログ記録を使用するのはなぜですか？

<Question
  choices={[
    {
      text: "開発者にとってコードをより楽しく魅力的にするため",
      explain: "絵文字は視覚的に魅力的ですが、より実用的な理由があります。"
    },
    {
      text: "サーバーがHubイベントに応答して自律的に実行される際のデバッグと監視を支援するため",
      explain: "正解です！エージェントがWebhookに自動的に応答するため、詳細なログはトラブルシューティングに重要です。",
      correct: true
    },
    {
      text: "FastMCPのログ記録要件に準拠するため",
      explain: "FastMCPは特定のログ記録形式や絵文字を要求しません。"
    },
    {
      text: "ログファイルのテキスト量を削減するため",
      explain: "絵文字はログファイルサイズを大幅に削減せず、これが主な目標ではありません。"
    }
  ]}
/>

このクイズの完了おめでとうございます🥳！要素を復習する必要がある場合は、時間をかけて章を再訪し、知識を強化してください。 