# クイズ2：プルリクエストエージェント統合

MCPクライアント統合とwebhook処理を含む、完全なプルリクエストエージェントシステムの知識をテストしてください。

### Q1: プルリクエストエージェントアーキテクチャにおけるwebhookリスナーの主な目的は何ですか？

<Question
  choices={[
    {
      text: "プルリクエストを管理するためのユーザーインターフェースを提供する",
      explain: "webhookリスナーはGitHubイベントを処理しますが、ユーザーインターフェースは提供しません。"
    },
    {
      text: "Hugging Face Hubディスカッションコメントイベントをリアルタイムで受信・処理する",
      explain: "正解！webhookリスナーはHubディスカッションイベントに応答してエージェントアクションをトリガーします。",
      correct: true
    },
    {
      text: "プルリクエストデータをデータベースに永続的に保存する",
      explain: "PRデータを処理する場合もありますが、主な役割はイベント処理であり、ストレージではありません。"
    },
    {
      text: "Hugging Face Hubでユーザーを認証する",
      explain: "webhookリスナーはイベントを処理しますが、ユーザー認証は行いません。"
    }
  ]}
/>

### Q2: エージェントベースのMCPクライアント実装において、クライアントはMCPサーバーにどのように接続しますか？

<Question
  choices={[
    {
      text: "同一プロセス内で直接関数呼び出しを通じて",
      explain: "エージェントは直接関数呼び出しではなく、サブプロセス通信を使用します。"
    },
    {
      text: "stdio接続タイプを使用してMCPサーバーとサブプロセスとして通信する",
      explain: "正解！エージェントは'python mcp_server.py'でMCPサーバーを起動し、stdin/stdoutを介して通信します。",
      correct: true
    },
    {
      text: "共有ディレクトリにファイルを書き込むことによって",
      explain: "MCPはリアルタイム通信を使用し、ファイルベースの通信は使用しません。"
    },
    {
      text: "HTTP REST API呼び出しを通じて",
      explain: "stdio接続タイプはHTTPを使用しません - 標準入力/出力ストリームを使用します。"
    }
  ]}
/>

### Q3: webhookハンドラーがリクエストを同期的に処理する代わりに、FastAPIの`background_tasks.add_task()`を使用する理由は何ですか？

<Question
  choices={[
    {
      text: "サーバーメモリ使用量を削減するため",
      explain: "バックグラウンドタスクは必ずしもメモリ使用量を削減しません。"
    },
    {
      text: "Hugging Face Hubの要件に準拠するため",
      explain: "Hubはタイムリーなレスポンスを期待しますが、これは特定のHub要件ではありません。"
    },
    {
      text: "複雑なタグ処理をバックグラウンドで実行しながら、レスポンスを迅速に（10秒以内に）返すため",
      explain: "正解！webhookエンドポイントは迅速に応答しなければならず、そうでなければ送信プラットフォームによって失敗とみなされます。",
      correct: true
    },
    {
      text: "複数のwebhookリクエストを並行して処理できるようにするため",
      explain: "これにより並列処理が可能になりますが、主な理由は応答時間要件です。"
    }
  ]}
/>

### Q4: webhookハンドラーで`X-Webhook-Secret`ヘッダーを検証する目的は何ですか？

<Question
  choices={[
    {
      text: "webhookを送信したリポジトリを特定するため",
      explain: "リポジトリ情報はwebhookペイロードから取得され、シークレットヘッダーからではありません。"
    },
    {
      text: "不正なリクエストを防ぎ、webhookがHugging Faceからの正当なものであることを確認するため",
      explain: "正解！共有シークレットはHugging Faceとあなたのアプリケーション間の認証として機能します。",
      correct: true
    },
    {
      text: "webhookペイロードデータをデコードするため",
      explain: "シークレットは認証用であり、ペイロードデータのデコード用ではありません。"
    },
    {
      text: "使用するMCPツールを決定するため",
      explain: "ツール選択はwebhookコンテンツに基づいており、シークレットヘッダーではありません。"
    }
  ]}
/>

### Q5: エージェント実装において、`await agent_instance.load_tools()`が呼び出されたときに何が起こりますか？

<Question
  choices={[
    {
      text: "Hugging Face Hubからツールをダウンロードする",
      explain: "ツールはローカルMCPサーバーツールであり、Hubからダウンロードされません。"
    },
    {
      text: "接続されたサーバーからMCPツール（get_current_tagsとadd_new_tag）を発見し、利用可能にする",
      explain: "正解！これによりMCPサーバーが提供するツールを発見し、エージェントの推論エンジンで利用できるようにします。",
      correct: true
    },
    {
      text: "FastAPI webhookサーバーを起動する",
      explain: "load_tools()はMCPツール発見に特化しており、webサーバーの起動ではありません。"
    },
    {
      text: "Hugging Face APIで認証する",
      explain: "認証はエージェント作成時に行われ、ツール読み込み時ではありません。"
    }
  ]}
/>

### Q6: 自然言語命令を処理する際に、エージェントはどのようにMCPツールを知的に使用しますか？

<Question
  choices={[
    {
      text: "動作するまで利用可能なツールをランダムに呼び出す",
      explain: "エージェントは推論を使用して、どのツールをどの順序で呼び出すかを決定します。"
    },
    {
      text: "常にget_current_tagsを最初に呼び出し、次にadd_new_tagを呼び出す",
      explain: "これは一般的なパターンかもしれませんが、エージェントは命令に基づいて使用するツールを推論します。"
    },
    {
      text: "命令を推論し、どのツールをどの順序で呼び出すかを決定する",
      explain: "正解！エージェントは複雑な命令を理解し、自動的にツール実行計画を作成できます。",
      correct: true
    },
    {
      text: "命令で明示的な関数呼び出しが指定されている必要がある",
      explain: "エージェントは明示的な関数仕様なしに自然言語命令で動作できます。"
    }
  ]}
/>

### Q7: webhookイベントがタグ処理をトリガーするかどうかを決定するフィルタリングロジックは何ですか？

<Question
  choices={[
    {
      text: "すべてのwebhookイベントがタイプに関係なく処理される",
      explain: "ハンドラーは関連するもののみを処理するためにイベントをフィルタリングします。"
    },
    {
      text: "action='create'かつscope='discussion.comment'のイベントのみ",
      explain: "正解！これにより新しいディスカッションコメントのみを処理し、他のHubイベントを無視します。",
      correct: true
    },
    {
      text: "検証済みリポジトリオーナーからのイベントのみ",
      explain: "フィルタリングはイベントタイプに基づいており、ユーザー検証ステータスではありません。"
    },
    {
      text: "コメントに「tag」という単語が含まれているイベントのみ",
      explain: "イベントフィルタリングはコンテンツ分析の前に行われます - 最初にイベントタイプでフィルタリングします。"
    }
  ]}
/>

このクイズを完了おめでとうございます！要素を復習する必要がある場合は、時間をかけてチャプターを見直して知識を強化してください。 