# モジュール2：GitHub Actions統合

## 静寂な失敗の襲来

CodeCraft Studiosでの2週目。モジュール1で作成したPRエージェントは既に開発者のより良いプルリクエスト作成を支援しています - Sarahの最新PRには、Mikeの調査時間を20分節約した明確な説明がありました。チームは大喜びです！

しかし、その後災害が起こります。

金曜日の午後、重要なバグが本番環境に到達しました。決済システムがダウンし、顧客が苦情を言い、チームは調査のために奔走します。2時間のストレスフルな時間の後、根本原因を発見しました：火曜日のCI実行でのテスト失敗で、誰も気づいていませんでした。

「これを見逃すなんて？」とチームリーダーがGitHub Actionsをスクロールしながら尋ねます。「テストは明らかに失敗していたのに、47のリポジトリと数十の日次コミットで、誰がすべてのビルドをチェックする時間があるでしょうか？」

チームは、CI/CDパイプラインへのリアルタイムの可視性が必要だと認識しますが、すべてのプロジェクトでGitHub Actionsを手動でチェックするのはスケーラブルではありません。問題を監視し、即座にアラートする自動化が必要です。

**あなたのミッション**：MCPサーバーをWebhook機能で拡張し、GitHub Actionsを監視して、もう一つの失敗が気づかれずに通り過ぎることがないようにする。

## 構築するもの

このモジュールは、静的ファイル分析（モジュール1）と動的チーム通知（モジュール3）の間のギャップを埋めます。PRエージェントを包括的な開発監視システムに変換するリアルタイム機能を追加します。

モジュール1で作成した基盤の上に、以下を追加します：
- GitHub Actionsイベントを受信するための**Webhookサーバー**
- CI/CDステータスを監視するための**新しいツール**
- 一貫したワークフローパターンを提供する**MCPプロンプト**
- GitHubリポジトリとの**リアルタイム統合**

### スクリーンキャスト：リアルタイムCI/CD監視の実践！🎯

<Youtube id="XIEnmCicFXk" />

**セットアップ**：CodeCraft Studiosの新しいシステムが本番環境に到達する前に失敗をキャッチする様子をご覧ください：
1. **GitHub Webhooks** - サーバーにイベントを送信する実際のWebhook設定を確認
2. **失敗したテスト** - 以前は気づかれなかった赤いX？もう違います！
3. **ローカル開発** - Webhookサーバーとcloudflare tunnelが連携して動作

**リアルタイムでのMCPマジック**：Claudeが3つの主要リクエストに対応：
- **「どのGitHub Actionsイベントを受信しましたか？」** - Claudeが新しいツールを使用して最近のアクティビティをチェック
- **「CI結果を分析」** - Claudeがテスト失敗を深く調査し、実用的な洞察を提供する様子を確認
- **「デプロイメント要約を作成」** - MCPプロンプトがClaudeをガイドしてチームフレンドリーな更新を作成する様子を確認

**もう静寂な失敗はありません**🚨：火曜日の失敗したテストから来た重要なバグを覚えていますか？このシステムがあれば、Claudeは即座にそれを捕捉したでしょう。スクリーンキャストは、MCPサーバーがGitHubの生のWebhookデータを明確で実用的なアラートに変換する正確な方法を示しています。

**これが特別な理由**：モジュール1のPRエージェントは静的でした - 尋ねられたときにコードを分析しました。このモジュール2の拡張は動的です - CI/CDパイプラインを24/7監視し、Claudeがリアルタイムの洞察を提供するのを支援します。もう金曜日の午後のサプライズはありません！

## 学習目標

このモジュールの終わりまでに、以下のことを理解します：
1. MCPサーバーと並行してWebhookサーバーを実行する方法
2. GitHub Webhookを受信・処理する方法
3. 標準化されたワークフローのためのMCPプロンプトを作成する方法
4. ローカルWebhookテスト用にCloudflare Tunnelを使用する方法

## 前提条件

モジュール1の作業を直接基盤として構築するため、以下を確認してください：
- **完了したモジュール1：MCPサーバーの構築** - 同じコードベースを拡張します
- **GitHub Actionsの基本的な理解** - CI/CDワークフローが何かを知っている必要があります
- **Actions有効なGitHubリポジトリ** - シンプルなワークフローファイルでも問題ありません
- **Cloudflare Tunnel（cloudflared）のインストール** - これがローカルWebhookサーバーをGitHubに公開します

## 主要概念

### MCPプロンプト

プロンプトは、Claudeを複雑なワークフローに導く再利用可能なテンプレートです。ツール（Claudeが自動的に呼び出す）とは異なり、プロンプトはユーザーが開始し、構造化されたガイダンスを提供します。

使用例：
- CI/CD結果を一貫して分析する
- 標準化されたデプロイメント要約を作成する
- 失敗を体系的にトラブルシューティングする

### Webhook統合

MCPサーバーは2つのサービスを実行します：
1. MCPサーバー（Claudeと通信）
2. ポート8080のWebhookサーバー（GitHubイベントを受信）

これにより、ClaudeがリアルタイムのCI/CDイベントに反応できます！

<Tip>

**アーキテクチャの洞察**：MCP通信とWebhook処理に別々のサービスを実行することは、関心の明確な分離です。WebhookサーバーはHTTPの複雑さを処理し、MCPサーバーはデータ分析とClaude統合に集中します。

</Tip>

## プロジェクト構造

```
github-actions-integration/
├── starter/          # あなたの開始点
│   ├── server.py     # モジュール1のコード + TODO
│   ├── pyproject.toml
│   └── README.md
└── solution/         # 完全な実装
    ├── server.py     # 完全なWebhook + プロンプト
    ├── pyproject.toml
    └── README.md
```

## 実装手順

### ステップ1：Webhookサーバーのセットアップと実行

既存ファイルで作業したモジュール1とは異なり、このモジュールではリアルタイムイベントハンドリングを導入します。スターターコードには以下が含まれます：
- **モジュール1の実装** - 既存のPR分析ツールすべて
- **完全なWebhookサーバー**（`webhook_server.py`） - GitHubイベントを受信する準備完了

1. 依存関係をインストール（モジュール1と同じ）：
   ```bash
   uv sync
   ```

2. Webhookサーバーを開始（別のターミナルで）：
   ```bash
   python webhook_server.py
   ```

このサーバーはGitHub Webhookを受信し、`github_events.json`に保存します。

**Webhookイベント保存の仕組み：**
- 各着信GitHub Webhook（push、pull request、ワークフロー完了など）はJSONファイルに追加されます
- イベントはタイムスタンプ付きで保存され、最近のアクティビティを簡単に見つけられます
- ファイルはMCPツールが読み取って分析できるシンプルなイベントログとして機能します
- データベースは不要 - すべてシンプルで読みやすいJSON形式で保存されます

### ステップ2：イベントストレージへの接続

これで、MCPサーバー（モジュール1から）をWebhookデータに接続します。これはHTTPリクエストを直接処理するよりもはるかにシンプルです - WebhookサーバーがすべてのHTTPの重い作業を行い、イベントをJSONファイルに保存します。

Webhookイベントを読み取るパスを追加：

```python
# Webhookサーバーがイベントを保存するファイル
EVENTS_FILE = Path(__file__).parent / "github_events.json"
```

WebhookサーバーがすべてのHTTPの詳細を処理します - JSONファイルを読み取るだけです！この関心の分離により、MCPサーバーは最も得意なことに集中できます。

<Tip>

**開発のヒント**：HTTPリクエストではなくファイルで作業することで、テストがはるかに簡単になります。Webhookを設定せずに`github_events.json`に手動でイベントを追加してツールをテストできます。

</Tip>

### ステップ3：GitHub Actionsツールを追加

モジュール1でファイル分析用のツールを作成したのと同様に、今度はCI/CD分析用のツールを作成します。これらのツールは既存のPR分析ツールと並行して動作し、Claudeにコード変更とビルドステータスの両方の完全なビューを提供します。

<Tip>

**注意**：スターターコードには既にモジュール1の出力制限修正が含まれているため、トークン制限エラーは発生しません。このモジュールの新しい概念に集中してください！

</Tip>

2つの新しいツールを実装：

1. **`get_recent_actions_events`**：
   - `EVENTS_FILE`から読み取り
   - 最新のイベントを返す（制限まで）
   - ファイルが存在しない場合は空のリストを返す

2. **`get_workflow_status`**：
   - ファイルからすべてのイベントを読み取り
   - workflow_runイベントをフィルタリング
   - ワークフロー名でグループ化し、最新のステータスを表示

これらのツールにより、ClaudeはCI/CDパイプラインを分析できます。

### ステップ4：MCPプロンプトを作成

これで初めてのMCPプロンプトを追加します！ツール（Claudeが自動的に呼び出す）とは異なり、プロンプトはユーザーがClaudeと一貫して相互作用するのを支援するテンプレートです。複雑なワークフローを通じてClaudeをガイドする「会話のきっかけ」と考えてください。

モジュール1はデータアクセス用のツールに焦点を当てましたが、このモジュールはワークフローガイダンス用のプロンプトを導入します。

異なるワークフローパターンを実証する4つのプロンプトを実装：

1. **`analyze_ci_results`**：包括的なCI/CD分析
2. **`create_deployment_summary`**：チームフレンドリーな更新
3. **`generate_pr_status_report`**：コード + CIレポートの組み合わせ
4. **`troubleshoot_workflow_failure`**：体系的なデバッグ

各プロンプトは、Claudeが従うべき明確な指示を含む文字列を返す必要があります。

### ステップ5：Cloudflare Tunnelでテスト

さて、興奮する部分です - 実際のGitHubイベントで拡張されたMCPサーバーをテストします！実際の開発環境と同じように、複数のサービスを一緒に実行します。

1. MCPサーバーを開始（モジュール1と同じコマンド）：
   ```bash
   uv run server.py
   ```

2. 別のターミナルでCloudflare Tunnelを開始：
   ```bash
   cloudflared tunnel --url http://localhost:8080
   ```

3. tunnel URLでGitHub Webhookを設定

4. プロンプトを使用してClaude Codeでテスト

## 演習

### 演習1：カスタムワークフロープロンプト
以下を組み合わせてPRレビューを支援する新しいプロンプトを作成：
- モジュール1ツールからのコード変更
- モジュール2ツールからのCI/CDステータス
- レビュアー用のチェックリスト形式

### 演習2：イベントフィルタリング
`get_workflow_status`を拡張して以下を行う：
- ワークフロー結論でフィルタリング（成功/失敗）
- リポジトリでグループ化
- 最後の実行からの時間を表示

### 演習3：通知システム
以下を行うツールを追加：
- どのイベントが「見られた」かを追跡
- 新しい失敗をハイライト
- 通知すべきチームメンバーを提案

## 一般的な問題

### Webhookがイベントを受信しない
- Cloudflare Tunnelが実行中であることを確認
- GitHub Webhook設定をチェック（最近の配信を表示する必要があります）
- ペイロードURLに`/webhook/github`が含まれていることを確認

### プロンプトが動作しない
- FastMCPプロンプトは単純に文字列を返します
- 関数が`@mcp.prompt()`でデコレートされていることを確認

### Webhookサーバーの問題
- webhook_server.pyが別のターミナルで実行されていることを確認
- ポート8080が空いていることをチェック：`lsof -i :8080`
- イベントファイルは最初のイベント受信時に自動的に作成されます

## 次のステップ

優秀な作業です！MCPサーバーにリアルタイム機能を正常に追加しました。以下のことができるシステムができました：

- **コード変更を分析**（モジュール1から）
- **リアルタイムでCI/CDイベントを監視**（このモジュールから）
- **MCPプロンプトを使用**して一貫したワークフローガイダンスを提供
- **ファイルベースアーキテクチャ**を通じてWebhookイベントを処理

### モジュール2での主要な成果：
- 初めてのWebhook統合を構築
- ワークフロー標準化のためのMCPプロンプトを学習
- リアルタイムデータで動作するツールを作成
- イベント駆動自動化のパターンを確立

### 次にすべきこと：
1. `/projects/unit3/github-actions-integration/solution/`の**解決方法を確認**して異なる実装アプローチを確認
2. **プロンプトを実験**してみる - 異なるタイプのGitHubイベントに使用してみる
3. **統合をテスト**する - 単一の会話でClaudeとのモジュール1ファイル分析ツールとモジュール2イベント監視を組み合わせる
4. **モジュール3に進む** - Slack統合を追加して自動化パイプラインを完成させる

モジュール3では、チームが実際に使用できる完全なワークフローにすべてをまとめます！

### ストーリーは続きます...
監視システムが動作しています！CodeCraft StudiosはCI/CDの失敗をリアルタイムでキャッチし、チームはデプロイメントについてはるかに自信を持てるようになりました。しかし、来週は新しい課題をもたらします：情報サイロが重複作業と機会の見逃しを引き起こしています。モジュール3では、皆がループに入り続けるインテリジェントなチーム通知で自動化システムを完成させます。

## 追加リソース

- [MCPプロンプトドキュメント](https://modelcontextprotocol.io/docs/concepts/prompts)
- [GitHub Webhooksガイド](https://docs.github.com/en/developers/webhooks-and-events)
- [Cloudflare Tunnelドキュメント](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps)