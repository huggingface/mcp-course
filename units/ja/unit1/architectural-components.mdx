# MCPのアーキテクチャコンポーネント

前のセクションでは、MCPの主要概念と用語について説明しました。今度は、MCPエコシステムを構成するアーキテクチャコンポーネントについてより深く掘り下げてみましょう。

## ホスト、クライアント、サーバー

Model Context Protocol（MCP）は、AIモデルと外部システム間の構造化された通信を可能にするクライアント・サーバー・アーキテクチャ上に構築されています。

![MCP Architecture](https://huggingface.co/datasets/mcp-course/images/resolve/main/unit1/4.png)

MCPアーキテクチャは、それぞれ明確に定義された役割と責任を持つ3つの主要コンポーネントで構成されています：ホスト、クライアント、サーバー。前のセクションでこれらについて触れましたが、各コンポーネントとその責任についてより深く掘り下げてみましょう。

### ホスト

**ホスト**は、エンドユーザーが直接インタラクトするユーザー向けAIアプリケーションです。

例として以下があります：
- OpenAI ChatGPTやAnthropicのClaude DesktopのようなAIチャットアプリ
- CursorのようなAI強化IDE、またはContinue.devのようなツールとの統合
- LangChainやsmolagentsのようなライブラリで構築されたカスタムAIエージェントやアプリケーション

ホストの責任には以下が含まれます：
- ユーザーインタラクションと許可の管理
- MCPクライアントを介したMCPサーバーへの接続開始
- ユーザーリクエスト、LLM処理、外部ツール間の全体的なフローの統率
- 結果を一貫した形式でユーザーに渡すレンダリング

ほとんどの場合、ユーザーはニーズと好みに基づいてホストアプリケーションを選択します。たとえば、開発者は強力なコード編集機能を求めてCursorを選択するかもしれませんし、ドメインエキスパートはsmolagentsで構築されたカスタムアプリケーションを使用するかもしれません。

### クライアント

**クライアント**は、特定のMCPサーバーとのコミュニケーションを管理するホストアプリケーション内のコンポーネントです。主要な特徴には以下が含まれます：

- 各クライアントは単一のサーバーとの1:1接続を維持します
- MCPコミュニケーションのプロトコルレベルの詳細を処理します
- ホストのロジックと外部サーバー間の中介役として機能します

### サーバー

**サーバー**は、MCPプロトコルを介してAIモデルに機能を公開する外部プログラムまたはサービスです。サーバーは：

- 特定の外部ツール、データソース、またはサービスへのアクセスを提供します
- 既存の機能の周りの軽量なラッパーとして機能します
- ローカル（ホストと同じマシン上）またはリモート（ネットワーク経由）で実行できます
- クライアントが発見し、使用できる標準化された形式で機能を公開します

## コミュニケーションフロー

一般的なMCPワークフローでこれらのコンポーネントがどのようにインタラクトするかを検討してみましょう：

<Tip>

次のセクションでは、これらのコンポーネントを実用的な例で可能にするコミュニケーションプロトコルについてより深く掘り下げていきます。

</Tip>

1. **ユーザーインタラクション**: ユーザーが**ホスト**アプリケーションとインタラクトし、意図やクエリを表現します。

2. **ホスト処理**: **ホスト**がユーザーの入力を処理し、リクエストを理解し、どの外部機能が必要になる可能性があるかを決定するためにLLMを使用する可能性があります。

3. **クライアント接続**: **ホスト**がその**クライアント**コンポーネントに適切なサーバーに接続するよう指示します。

4. **機能発見**: **クライアント**が**サーバー**にクエリを送って、どのような機能（ツール、リソース、プロンプト）を提供しているかを発見します。

5. **機能呼び出し**: ユーザーのニーズやLLMの判断に基づいて、ホストが**クライアント**に**サーバー**から特定の機能を呼び出すよう指示します。

6. **サーバー実行**: **サーバー**がリクエストされた機能を実行し、結果を**クライアント**に返します。

7. **結果統合**: **クライアント**がこれらの結果を**ホスト**に中継し、ホストはそれらをLLMのコンテキストに組み込むか、直接ユーザーに提示します。

このアーキテクチャの主要な利点は、そのモジュラー性です。単一の**ホスト**が異なる**クライアント**を介して複数の**サーバー**に同時に接続できます。新しい**サーバー**を既存の**ホスト**の変更を必要とせずにエコシステムに追加できます。機能を異なる**サーバー**間で簡単に組み合わせることができます。

<Tip>

前のセクションで議論したように、このモジュラー性は、伝統的なM×N統合問題（M個のAIアプリケーションがN個のツール/サービスに接続）を、各ホストとサーバーがMCP標準を一度だけ実装するより管理しやすいM+N問題に変換します。

</Tip>

アーキテクチャはシンプルに見えるかもしれませんが、その力はコミュニケーションプロトコルの標準化とコンポーネント間の責任の明確な分離にあります。この設計により、AIモデルが常に成長し続ける外部ツールやデータソースの配列とシームレスに接続できる結束力のあるエコシステムが可能になります。

## 結論

これらのインタラクションパターンは、MCPの設計と進化を形作るいくつかの主要原則によってガイドされています。プロトコルはAI接続のための普遍的プロトコルを提供することで**標準化**を強調し、コアプロトコルを直接的に保ちながら高度な機能を可能にすることで**シンプルさ**を維持します。機密な操作に対して明示的なユーザー承認を要求することで**安全性**が優先され、発見性は機能の動的発見を可能にします。プロトコルは**拡張性**を念頭に置いて構築され、バージョニングと機能交渉を通じて進化をサポートし、異なる実装と環境間での**相互運用性**を保証します。

次のセクションでは、これらのコンポーネントが効果的に連携できるようにするコミュニケーションプロトコルを探求していきます。