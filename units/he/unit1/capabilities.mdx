# הבנת יכולות MCP

שרתי MCP חושפים מגוון יכולות ללקוחות דרך פרוטוקול התקשורת. יכולות אלה נופלות לארבע קטגוריות עיקריות, כל אחת עם מאפיינים ייחודיים ומקרי שימוש. בואו נחקור את המרכיבים הבסיסיים האלה שמהווים את היסוד לפונקציונליות של MCP.

<Tip>

בסעיף זה, נציג דוגמאות כפונקציות אגנוסטיות למסגרת בכל שפה. זאת כדי להתמקד במושגים ובאופן שבו הם עובדים יחד, ולא במורכבויות של מסגרת כלשהי.

ביחידות הבאות, נראה כיצד מושגים אלה מיושמים בקוד ספציפי ל-MCP.

</Tip>

## כלים (Tools)

כלים הם פונקציות או פעולות הניתנות להפעלה שמודל הבינה המלאכותית יכול להפעיל דרך פרוטוקול MCP.

- **שליטה**: כלים הם בדרך כלל **נשלטים על ידי המודל**, כלומר שמודל הבינה המלאכותית (LLM) מחליט מתי לקרוא להם בהתבסס על בקשת המשתמש וההקשר.
- **בטיחות**: בגלל היכולת שלהם לבצע פעולות עם תופעות לוואי, הפעלת כלי יכולה להיות מסוכנת. לכן, הם בדרך כלל דורשים אישור משתמש מפורש.
- **מקרי שימוש**: שליחת הודעות, יצירת כרטיסים, שאילתות API, ביצוע חישובים.

**דוגמה**: כלי מזג אוויר שמביא נתוני מזג אוויר עדכניים למיקום נתון:

<hfoptions id="tool-example">
<hfoption id="python">

```python
def get_weather(location: str) -> dict:
    """קבל את מזג האוויר הנוכחי למיקום מסוים."""
    # התחבר ל-API של מזג אוויר והבא נתונים
    return {
        "temperature": 72,
        "conditions": "Sunny",
        "humidity": 45
    }
```

</hfoption>
<hfoption id="javascript">

```javascript
function getWeather(location) {
    // התחבר ל-API של מזג אוויר והבא נתונים
    return {
        temperature: 72,
        conditions: 'Sunny',
        humidity: 45
    };
}
```

</hfoption>
</hfoptions>

## משאבים (Resources)

משאבים מספקים גישה לקריאה בלבד למקורות מידע, מאפשרים למודל הבינה המלאכותית לאחזר הקשר ללא ביצוע לוגיקה מורכבת.

- **שליטה**: משאבים **נשלטים על ידי היישום**, כלומר יישום המארח בדרך כלל מחליט מתי לגשת אליהם.
- **אופי**: הם מתוכננים לאחזור מידע עם חישוב מינימלי, בדומה לנקודות קצה של GET ב-REST API.
- **בטיחות**: מכיוון שהם לקריאה בלבד, הם בדרך כלל מציגים סיכוני אבטחה נמוכים יותר מאשר כלים.
- **מקרי שימוש**: גישה לתוכן קבצים, אחזור רשומות מסד נתונים, קריאת מידע תצורה.

**דוגמה**: משאב המספק גישה לתוכן קובץ:

<hfoptions id="resource-example">
<hfoption id="python">

```python
def read_file(file_path: str) -> str:
    """קרא את תוכן הקובץ בנתיב המצוין."""
    with open(file_path, 'r') as f:
        return f.read()
```

</hfoption>
<hfoption id="javascript">

```javascript
function readFile(filePath) {
    // שימוש ב-fs.readFile לקריאת תוכן קובץ
    const fs = require('fs');
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                reject(err);
                return;
            }
            resolve(data);
        });
    });
}
```

</hfoption>
</hfoptions>

## הנחיות (Prompts)

הנחיות הן תבניות או זרימות עבודה מוגדרות מראש המנחות את האינטראקציה בין המשתמש, מודל הבינה המלאכותית והיכולות של השרת.

- **שליטה**: הנחיות **נשלטות על ידי המשתמש**, לעתים קרובות מוצגות כאפשרויות בממשק המשתמש של יישום המארח.
- **מטרה**: הן מבנות אינטראקציות לשימוש אופטימלי בכלים ומשאבים זמינים.
- **בחירה**: משתמשים בדרך כלל בוחרים הנחיה לפני שמודל הבינה המלאכותית מתחיל לעבד, וקובעים הקשר לאינטראקציה.
- **מקרי שימוש**: זרימות עבודה נפוצות, תבניות משימה מיוחדות, אינטראקציות מודרכות.

**דוגמה**: תבנית הנחיה ליצירת ביקורת קוד:

<hfoptions id="prompt-example">
<hfoption id="python">

```python
def code_review(code: str, language: str) -> list:
    """
    יצירת ביקורת קוד עבור קטע הקוד שסופק.
    """
    return [
        {
            "role": "system",
            "content": f"אתה מבקר קוד שבוחן קוד {language}. ספק ביקורת מפורטת המדגישה שיטות עבודה מומלצות, בעיות פוטנציאליות, והצעות לשיפור."
        },
        {
            "role": "user",
            "content": f"אנא בדוק את קוד ה-{language} הזה:\n\n```{language}\n{code}\n```"
        }
    ]
```

</hfoption>
<hfoption id="javascript">

```javascript
function codeReview(code, language) {
    return [
        {
            role: 'system',
            content: `אתה מבקר קוד שבוחן קוד ${language}. ספק ביקורת מפורטת המדגישה שיטות עבודה מומלצות, בעיות פוטנציאליות, והצעות לשיפור.`
        },
        {
            role: 'user',
            content: `אנא בדוק את קוד ה-${language} הזה:\n\n\`\`\`${language}\n${code}\n\`\`\``
        }
    ];
}
```

</hfoption>
</hfoptions>

## דגימה (Sampling)

דגימה מאפשרת לשרתים לבקש מהלקוח (ספציפית, יישום המארח) לבצע אינטראקציות LLM.

- **שליטה**: דגימה **מופעלת על ידי השרת** אך דורשת סיוע מהלקוח/מארח.
- **מטרה**: היא מאפשרת התנהגויות סוכניות מונעות-שרת ופוטנציאלית אינטראקציות רקורסיביות או רב-שלביות.
- **בטיחות**: בדומה לכלים, פעולות דגימה בדרך כלל דורשות אישור משתמש.
- **מקרי שימוש**: משימות מורכבות רב-שלביות, זרימות עבודה של סוכנים אוטונומיים, תהליכים אינטראקטיביים.

**דוגמה**: שרת עשוי לבקש מהלקוח לנתח נתונים שהוא עיבד:

<hfoptions id="sampling-example">
<hfoption id="python">

```python
def request_sampling(messages, system_prompt=None, include_context="none"):
    """בקש דגימת LLM מהלקוח."""
    # ביישום אמיתי, זה היה שולח בקשה ללקוח
    return {
        "role": "assistant",
        "content": "ניתוח הנתונים שסופקו..."
    }
```

</hfoption>
<hfoption id="javascript">

```javascript
function requestSampling(messages, systemPrompt = null, includeContext = 'none') {
    // ביישום אמיתי, זה היה שולח בקשה ללקוח
    return {
        role: 'assistant',
        content: 'ניתוח הנתונים שסופקו...'
    };
}

function handleSamplingRequest(request) {
    const { messages, systemPrompt, includeContext } = request;
    // ביישום אמיתי, זה היה מעבד את הבקשה ומחזיר תגובה
    return {
        role: 'assistant',
        content: 'תגובה לבקשת הדגימה...'
    };
}
```

</hfoption>
</hfoptions>

זרימת הדגימה עוקבת אחר השלבים הבאים:
1. השרת שולח בקשת `sampling/createMessage` ללקוח
2. הלקוח בוחן את הבקשה ויכול לשנות אותה
3. הלקוח דוגם מ-LLM
4. הלקוח בוחן את התוצאה
5. הלקוח מחזיר את התוצאה לשרת

<Tip>

עיצוב זה של אדם-בלולאה מבטיח שמשתמשים שומרים על שליטה במה שה-LLM רואה ומייצר. בעת יישום דגימה, חשוב לספק הנחיות ברורות, מובנות היטב ולכלול הקשר רלוונטי.

</Tip>

## איך יכולות עובדות יחד

בואו נראה איך יכולות אלה עובדות יחד כדי לאפשר אינטראקציות מורכבות. בטבלה למטה, פירטנו את היכולות, מי שולט בהן, כיוון השליטה, ופרטים נוספים.

| יכולת | נשלט על ידי | כיוון | תופעות לוואי | נדרש אישור | מקרי שימוש אופייניים |
|------------|---------------|-----------|--------------|-----------------|-------------------|
| כלים      | מודל (LLM)   | לקוח → שרת | כן (פוטנציאלית) | כן | פעולות, קריאות API, מניפולציית נתונים |
| משאבים  | יישום   | לקוח → שרת | לא (קריאה בלבד) | בדרך כלל לא | אחזור נתונים, איסוף הקשר |
| הנחיות    | משתמש          | שרת → לקוח | לא | לא (נבחר על ידי המשתמש) | זרימות עבודה מודרכות, תבניות מיוחדות |
| דגימה   | שרת        | שרת → לקוח → שרת | בעקיפין | כן | משימות רב-שלביות, התנהגויות סוכניות |

יכולות אלה מתוכננות לעבוד יחד בדרכים משלימות:

1. משתמש עשוי לבחור **הנחיה** כדי להתחיל זרימת עבודה מיוחדת
2. ההנחיה עשויה לכלול הקשר מ**משאבים**
3. במהלך העיבוד, מודל הבינה המלאכותית עשוי לקרוא ל**כלים** כדי לבצע פעולות ספציפיות
4. עבור פעולות מורכבות, השרת עשוי להשתמש ב**דגימה** כדי לבקש עיבוד LLM נוסף

ההבחנה בין מרכיבים בסיסיים אלה מספקת מבנה ברור לאינטראקציות MCP, מאפשרת למודלי בינה מלאכותית לגשת למידע, לבצע פעולות ולעסוק בזרימות עבודה מורכבות תוך שמירה על גבולות שליטה מתאימים.

## תהליך גילוי

אחת התכונות המרכזיות של MCP היא גילוי יכולות דינמי. כאשר לקוח מתחבר לשרת, הוא יכול לשאול על הכלים, המשאבים וההנחיות הזמינים דרך שיטות רשימה ספציפיות:

- `tools/list`: גלה כלים זמינים
- `resources/list`: גלה משאבים זמינים
- `prompts/list`: גלה הנחיות זמינות

מנגנון גילוי דינמי זה מאפשר ללקוחות להסתגל ליכולות הספציפיות שכל שרת מציע ללא צורך בידע מקודד מראש של פונקציונליות השרת.

## סיכום

הבנת המרכיבים הבסיסיים האלה היא חיונית לעבודה עם MCP ביעילות. על ידי אספקת סוגי יכולות מובחנים עם גבולות שליטה ברורים, MCP מאפשר אינטראקציות חזקות בין מודלי בינה מלאכותית ומערכות חיצוניות תוך שמירה על מנגנוני בטיחות ושליטה מתאימים.

בסעיף הבא, נחקור כיצד Gradio משתלב עם MCP כדי לספק ממשקים קלים לשימוש עבור יכולות אלה.
