# רכיבים ארכיטקטוניים של MCP

בסעיף הקודם, דנו במושגים המרכזיים ובטרמינולוגיה של MCP. כעת, בואו נעמיק יותר ברכיבים הארכיטקטוניים המרכיבים את המערכת האקולוגית של MCP.

## מארח (Host), לקוח (Client) ושרת (Server)

פרוטוקול הקשר המודל (MCP) בנוי על ארכיטקטורת לקוח-שרת המאפשרת תקשורת מובנית בין מודלי בינה מלאכותית ומערכות חיצוניות.

![ארכיטקטורת MCP](https://huggingface.co/datasets/mcp-course/images/resolve/main/unit1/4.png)

ארכיטקטורת ה-MCP מורכבת משלושה רכיבים עיקריים, כל אחד עם תפקידים ואחריות מוגדרים היטב: מארח, לקוח ושרת. נגענו באלה בסעיף הקודם, אבל בואו נעמיק בכל רכיב ובאחריות שלהם.

### מארח (Host)

ה**מארח** הוא יישום הבינה המלאכותית שמשתמשי הקצה מתקשרים איתו ישירות.

דוגמאות כוללות:
- אפליקציות צ'אט בינה מלאכותית כמו OpenAI ChatGPT או Anthropic's Claude Desktop
- סביבות פיתוח משולבות (IDE) משופרות בבינה מלאכותית כמו Cursor, או אינטגרציות לכלים כמו Continue.dev
- סוכנים ויישומי בינה מלאכותית מותאמים אישית שנבנו בספריות כמו LangChain או smolagents

האחריות של המארח כוללת:
- ניהול אינטראקציות משתמשים והרשאות
- יצירת חיבורים לשרתי MCP באמצעות לקוחות MCP
- תזמור הזרימה הכוללת בין בקשות משתמשים, עיבוד LLM וכלים חיצוניים
- הצגת תוצאות למשתמשים בפורמט קוהרנטי

ברוב המקרים, משתמשים יבחרו את יישום המארח שלהם בהתבסס על הצרכים וההעדפות שלהם. לדוגמה, מפתח עשוי לבחור ב-Cursor בזכות יכולות עריכת הקוד החזקות שלו, בעוד שמומחי תחום עשויים להשתמש ביישומים מותאמים אישית שנבנו ב-smolagents.

### לקוח (Client)

ה**לקוח** הוא רכיב בתוך יישום המארח שמנהל תקשורת עם שרת MCP ספציפי. מאפיינים מרכזיים כוללים:

- כל לקוח מתחזק חיבור 1:1 עם שרת יחיד
- מטפל בפרטים ברמת הפרוטוקול של תקשורת MCP
- פועל כמתווך בין הלוגיקה של המארח לבין השרת החיצוני

### שרת (Server)

ה**שרת** הוא תוכנית או שירות חיצוני שחושף יכולות למודלי בינה מלאכותית באמצעות פרוטוקול MCP. שרתים:

- מספקים גישה לכלים חיצוניים ספציפיים, מקורות מידע או שירותים
- פועלים כעטיפות קלות משקל סביב פונקציונליות קיימת
- יכולים לרוץ מקומית (על אותה מכונה כמו המארח) או מרחוק (דרך רשת)
- חושפים את היכולות שלהם בפורמט סטנדרטי שלקוחות יכולים לגלות ולהשתמש בו

## זרימת תקשורת

בואו נבחן כיצד רכיבים אלה מתקשרים בזרימת עבודה טיפוסית של MCP:

<Tip>

בסעיף הבא, נעמיק יותר בפרוטוקול התקשורת המאפשר רכיבים אלה עם דוגמאות מעשיות.

</Tip>

1. **אינטראקציית משתמש**: המשתמש מתקשר עם יישום ה**מארח**, מביע כוונה או שאילתה.

2. **עיבוד מארח**: ה**מארח** מעבד את קלט המשתמש, ופוטנציאלית משתמש ב-LLM להבנת הבקשה וקביעת אילו יכולות חיצוניות עשויות להיות נדרשות.

3. **חיבור לקוח**: ה**מארח** מנחה את רכיב ה**לקוח** שלו להתחבר לשרת(ים) המתאים(ים).

4. **גילוי יכולות**: ה**לקוח** שואל את ה**שרת** לגלות אילו יכולות (כלים, משאבים, הנחיות) הוא מציע.

5. **הפעלת יכולות**: בהתבסס על צרכי המשתמש או קביעת ה-LLM, המארח מורה ל**לקוח** להפעיל יכולות ספציפיות מה**שרת**.

6. **ביצוע שרת**: ה**שרת** מבצע את הפונקציונליות המבוקשת ומחזיר תוצאות ל**לקוח**.

7. **שילוב תוצאות**: ה**לקוח** מעביר תוצאות אלו בחזרה ל**מארח**, אשר משלב אותן בהקשר עבור ה-LLM או מציג אותן ישירות למשתמש.

יתרון מרכזי של ארכיטקטורה זו הוא המודולריות שלה. **מארח** יחיד יכול להתחבר למספר **שרתים** בו-זמנית באמצעות **לקוחות** שונים. **שרתים** חדשים יכולים להתווסף למערכת האקולוגית ללא דרישה לשינויים ב**מארחים** קיימים. ניתן לחבר יכולות בקלות בין **שרתים** שונים.

<Tip>

כפי שדנו בסעיף הקודם, מודולריות זו הופכת את בעיית האינטגרציה המסורתית של M×N (M יישומי בינה מלאכותית המתחברים ל-N כלים/שירותים) לבעיה יותר ניתנת לניהול של M+N, שבה כל מארח ושרת צריכים ליישם את תקן ה-MCP רק פעם אחת.

</Tip>

הארכיטקטורה עשויה להיראות פשוטה, אך כוחה טמון בסטנדרטיזציה של פרוטוקול התקשורת ובהפרדה הברורה של האחריות בין רכיבים. עיצוב זה מאפשר מערכת אקולוגית מלוכדת שבה מודלי בינה מלאכותית יכולים להתחבר באופן חלק למערך גדל והולך של כלים חיצוניים ומקורות מידע.

## סיכום

דפוסי אינטראקציה אלה מונחים על ידי מספר עקרונות מפתח המעצבים את התכנון והאבולוציה של MCP. הפרוטוקול מדגיש **סטנדרטיזציה** על ידי אספקת פרוטוקול אוניברסלי לקישוריות בינה מלאכותית, תוך שמירה על **פשטות** על ידי שמירת הפרוטוקול הבסיסי פשוט אך מאפשר תכונות מתקדמות. **בטיחות** מקבלת עדיפות על ידי דרישת אישור משתמש מפורש לפעולות רגישות, וגילוי מאפשר גילוי דינמי של יכולות. הפרוטוקול נבנה עם **הרחבה** בראש, תומך באבולוציה דרך גרסאות ומשא ומתן על יכולות, ומבטיח **יכולת פעולה הדדית** בין יישומים שונים וסביבות.

בסעיף הבא, נחקור את פרוטוקול התקשורת המאפשר לרכיבים אלה לעבוד יחד ביעילות.
